# 1内联函数
### 1.1 作用 提高程序运行速度的改进  
函数（类似于阅读文章停下看脚注，阅读完脚注回去看文章）  
内联函数（其的编译代码与其他代码内联起来，不用跳转。运行速度快，但内存消耗大）

## 2引用变量
 1、创建引用变量   2、将引用作函数参数  3、引用属性的特别之处就是会修改数据。 （使用const）  4、引用用作结构、类对象
 ### 何时使用引用
 原因：
 1、能修改调用函数中的数据对象
 2、通过传递引用不是整个数据对象，可以提高运行速度
 
 ### 对于传递的值而不做修改的函数
 1、数据对象很小，按值传递
 2、数据对象是数组，使用指针，并且是const指针
 3、较大的结构，使用const 指针或者const引用，提高效率。
 4，类对象，使用const引用
 
 ### 对于修改调用函数中数据的函数
 内置数据类型就指针、数组（指针）、结构（指针或者引用）、类对象（引用）。

## 3默认参数
例如 char *left(const char * str,int n=1)

注意对于带参数列表的函数 （必须）从右往左添加默认值  int harpo(int n,int m=4,int j=5) 这个可以  int haroo(int n,int m=4,int j)这个不可以。
形参赋值是 从左到右且不能跳过任何参数 beeps = garpo(3,,8)不可以。

## 4函数重载
重载的关键是：参数列表（也称函数特征标）。返回值不能函数重载。

何时使用：执行相同任务，使用不同形式的数据时。  关键字：名称修饰符

## 5函数模板
定义方式
template<typename AnyType>   //class 也可以
void swpa(AnyType &a,AnyType &b)
 {
   AnyType temp;
 temp=a;
 a=b;
 b=temp;
 }
 模板可以重载，特征标不一样。书P233例子是数组交换。
 
 ### 5.1函数模板的显示具体化和实例化。
 带尖括号的是显示具体化   template<>void Swap<int>(int &a,int &b);   //具体定制的类型
 不带尖括号的是模板显示实例化  template void Swap<int>(int,int);
 
 有个struct job
 显示具体化模板：template <>void swap<job>(job &a, job &b) //一定是job &a
                int main()
 
 模板并非函数定义，但使用int的模板实例是函数定义。叫：隐式实例化。

 
